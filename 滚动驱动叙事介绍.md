滚动驱动叙事正是 **Apple 产品页最“灵魂”的部分**。下面我会**只聚焦在「滚动驱动叙事 + 克制微动效」**，从**设计理念 → 体验结构 → 动效类型 → 认知心理 → 实现思路**，一步步拆给你看。

------

# 一、什么是「滚动驱动叙事」？（不是普通滚动）

先澄清一个常见误解 👇
**Apple 的页面不是“信息随滚动出现”**，而是：

> **滚动 = 时间轴
> 页面 = 产品发布会
> 用户 = 观众**

你不是在“找信息”，而是在**被导演带着走剧情**。

------

## 1️⃣ 传统网页 vs Apple 式网页

### 普通产品页（信息型）

- 滚动只是「翻页」
- 内容彼此独立
- 用户自己决定看什么

### Apple 产品页（叙事型）

- 滚动是「剧情推进」
- 前后内容强关联
- 页面在“引导你理解产品”

👉 **核心区别：是否有“叙事节奏”**

------

# 二、Apple 如何用「滚动」讲故事？

## 核心原则：**一屏 = 一个观点**

Apple 几乎严格遵守一个规则：

> ❌ 不在一屏里说两件重要的事
> ✅ 每一屏只传达一个“主张”

### 举例（Mac / iPhone 页面）

| 屏幕    | 讲什么             |
| ------- | ------------------ |
| 第 1 屏 | 这是一个革命性产品 |
| 第 2 屏 | 它的性能很强       |
| 第 3 屏 | 屏幕体验很惊艳     |
| 第 4 屏 | 日常使用有多爽     |
| 第 5 屏 | 技术细节（最后）   |

**滚动的本质 = 逻辑推进，而不是位移**

------

## 叙事顺序非常固定（这是重点）

Apple 几乎总是用这套顺序：

1. **情绪冲击（Wow）**
2. **感性理解（感觉好）**
3. **使用场景（我会用到）**
4. **理性证明（它确实强）**

👉 技术参数永远靠后
👉 第一屏永远不讲参数

------

# 三、为什么这种方式“让人停不下来”？

这是**认知心理 + 交互设计的结合**。

------

## 1️⃣ 利用「进度感」

当页面：

- 不断有内容“解锁”
- 每滚一下都有变化

大脑会产生一种感觉：

> “我已经看到一半了，不如看完吧”

这和你刷短视频、看发布会 PPT 是同一种机制。

------

## 2️⃣ 降低决策压力

普通页面的问题是：

> 「我要不要看这一段？」

Apple 的方式是：

> 「你不用选，我已经帮你选好了顺序」

👉 用户不用思考路径
👉 只需要“继续往下”

------

# 四、什么是「克制但精准的微动效」？

Apple 的动效有一个铁律：

> **如果去掉动画，内容依然成立**

动画不是主角，是“辅助理解”。

------

## 1️⃣ Apple 常用的 5 种微动效（非常重要）

### ① 缓慢位移（Parallax-lite）

- 产品图轻微上下 / 前后移动
- 幅度非常小（5%–10%）

作用：

> 让产品“有体积”，而不是一张平面图

------

### ② 缓慢缩放（Subtle Zoom）

- 滚动时图片微微放大
- 几乎察觉不到，但能“感觉到”

作用：

> 强化关注点，引导视线集中

------

### ③ 淡入（Opacity Fade）

- 文案不是“突然出现”
- 而是从 0 → 100

作用：

> 减少认知突兀感，让信息更容易被接受

------

### ④ 顺序出现（Stagger）

- 一行一行参数依次出现
- 而不是一整块砸出来

作用：

> 模拟“人讲话的节奏”

------

### ⑤ 固定 + 变化（Sticky Section）

- 背景 / 产品固定
- 文案在变化

作用：

> 强化“这是同一个核心点的不同解释”

------

## 2️⃣ Apple 不做什么（反而很重要）

❌ 弹跳
❌ 快速 easing
❌ 大幅旋转
❌ 炫技 3D
❌ 无意义的 hover 特效

**他们宁愿慢，也不要花。**

------

# 五、为什么 Apple 的动画“感觉很稳”？

这是很多人模仿失败的关键点。

------

## 1️⃣ 时间函数（Easing）极其克制

- 几乎不用 `ease-out-back`
- 常用：
  - linear
  - ease-in-out
  - 非常长的 duration（1s–2s）

👉 **慢 ≠ 卡
慢 = 高级**

------

## 2️⃣ 动画只在「用户触发」时发生

- 滚动 → 才动
- 停下 → 就停

没有“自己乱动”的元素
这让用户有**控制感**

------

# 六、从设计角度总结一句话

> **Apple 的交互不是“让你注意到动画”，
> 而是“让你忘记这是网页”。**

你记住的是：

- 产品
- 感受
- 理解

而不是：

- 哇这个动画好炫









非常好，这一步就**真正进入“工程层面”**了。下面我会用 **「能落地、少依赖、可维护」** 的方式，带你从 **架构 → CSS → 原生 JS 滚动控制 → 常见模式**，一步步实现 **Apple 式滚动叙事**。

> 目标：
> **不用重型库（不强依赖 GSAP / fullpage.js）**
> **用浏览器原生能力 + 少量 JS**

------

# 一、整体实现思路（先定架构，不要急着写动画）

Apple 式滚动叙事的本质不是动画，而是：

> **“滚动进度 → 状态变化”**

所以工程上你要做的是：

```
Scroll Position
      ↓
Scroll Progress（0~1）
      ↓
映射为视觉状态（opacity / transform / scale）
```

------

## 推荐的最小技术栈

- HTML：语义化 section
- CSS：`position: sticky` + `transform`
- JS：
  - `IntersectionObserver`（判断进入视口）
  - `requestAnimationFrame`（平滑更新）
- ❌ 不需要：
  - jQuery
  - fullpage.js
  - 重型动画库

------

# 二、页面结构（90% 的成功在这里）

## 标准 Apple 风页面骨架

```html
<body>
  <section class="scene hero">
    <div class="sticky">
      <h1>强得很。还很轻。</h1>
      <img src="product.png" />
    </div>
  </section>

  <section class="scene performance">
    <div class="sticky">
      <h2>性能，飞一样。</h2>
    </div>
  </section>

  <section class="scene display">
    <div class="sticky">
      <h2>屏幕，好看到舍不得眨眼。</h2>
    </div>
  </section>
</body>
```

------

## 关键点（非常重要）

### 1️⃣ 每个 `.scene` 都“很高”

```css
.scene {
  height: 200vh; /* 或 300vh */
}
```

为什么？

- 给滚动“留空间”
- 动画需要“时间轴”

------

### 2️⃣ 真正显示的内容是 sticky 的

```css
.sticky {
  position: sticky;
  top: 0;
  height: 100vh;

  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
```

**这一步是灵魂：**

> 页面在滚，但画面“钉住”

------

# 三、最核心：把滚动变成「0～1 的进度」

这是 Apple 风实现的分水岭。

------

## 计算 scroll progress（原生 JS）

```js
function getScrollProgress(section) {
  const rect = section.getBoundingClientRect();
  const windowHeight = window.innerHeight;

  const total = rect.height - windowHeight;
  const scrolled = -rect.top;

  return Math.min(Math.max(scrolled / total, 0), 1);
}
```

返回值：

- `0`：刚进入
- `1`：即将离开

------

## 在滚动中更新动画

```js
const scenes = document.querySelectorAll(".scene");

function onScroll() {
  scenes.forEach(scene => {
    const progress = getScrollProgress(scene);
    updateScene(scene, progress);
  });
  requestAnimationFrame(onScroll);
}

requestAnimationFrame(onScroll);
```

------

# 四、把进度映射为“Apple 风动画”

## 1️⃣ 淡入 + 上移（最常见）

```js
function updateScene(scene, p) {
  const el = scene.querySelector("h2");

  el.style.opacity = p;
  el.style.transform = `translateY(${(1 - p) * 40}px)`;
}
```

效果：

- 文案缓慢出现
- 不突兀、不抢戏

------

## 2️⃣ 缓慢缩放（产品图）

```js
const img = scene.querySelector("img");

const scale = 1 + p * 0.05;
img.style.transform = `scale(${scale})`;
```

⚠️ 建议：

- 最大不超过 `1.08`
- 否则就“俗了”

------

## 3️⃣ 多元素顺序出现（Stagger）

```js
const items = scene.querySelectorAll(".spec");

items.forEach((item, i) => {
  const delay = i * 0.15;
  const local = Math.min(Math.max((p - delay) / 0.3, 0), 1);

  item.style.opacity = local;
  item.style.transform = `translateY(${(1 - local) * 20}px)`;
});
```

------

# 五、用 IntersectionObserver 优化性能（强烈推荐）

不用每一帧都算所有 section。

```js
let activeScenes = new Set();

const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      activeScenes.add(entry.target);
    } else {
      activeScenes.delete(entry.target);
    }
  });
}, { threshold: 0 });

scenes.forEach(s => observer.observe(s));
```

然后只更新 active 的：

```js
activeScenes.forEach(scene => {
  const p = getScrollProgress(scene);
  updateScene(scene, p);
});
```

------

# 六、90% 模仿失败的真正原因（很关键）

### ❌ 错误 1：一屏做太多动画

👉 正确：**一个 section 只做 1–2 个变化**

### ❌ 错误 2：动画太快

👉 正确：**宁慢勿快**

### ❌ 错误 3：动效与内容无关

👉 正确：**动画 = 帮助理解**

